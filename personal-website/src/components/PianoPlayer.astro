---
// Define NOTE_FREQUENCIES only once in the frontmatter
const NOTE_FREQUENCIES: Record<string, number> = {
    // Lower octave
    C3: 130.81,
    "C#3": 138.59,
    D3: 146.83,
    "D#3": 155.56,
    E3: 164.81,
    F3: 174.61,
    "F#3": 185.0,
    G3: 196.0,
    "G#3": 207.65,
    A3: 220.0,
    "A#3": 233.08,
    B3: 246.94,

    // Middle octave
    C4: 261.63,
    "C#4": 277.18,
    D4: 293.66,
    "D#4": 311.13,
    E4: 329.63,
    F4: 349.23,
    "F#4": 369.99,
    G4: 392.0,
    "G#4": 415.3,
    A4: 440.0,
    "A#4": 466.16,
    B4: 493.88,

    // Upper octave
    C5: 523.25,
    "C#5": 554.37,
    D5: 587.33,
    "D#5": 622.25,
    E5: 659.25,
    F5: 698.46,
    "F#5": 739.99,
    G5: 783.99,
    "G#5": 830.61,
    A5: 880.0,
    "A#5": 932.33,
    B5: 987.77,
};

// Serialize the object to make it available to client-side JS
const serializedFrequencies = JSON.stringify(NOTE_FREQUENCIES);
---

<!-- Add this hidden element with the serialized data -->
<div
    id="piano-data"
    data-frequencies={serializedFrequencies}
    style="display:none;"
>
</div>

<div class="piano-container">
    <h2>My Piano Skills</h2>

    <!-- Piano Keyboard -->
    <div class="piano">
        <div class="keyboard">
            <!-- White keys -->
            {
                [
                    "A3",
                    "B3",
                    "C4",
                    "D4",
                    "E4",
                    "F4",
                    "G4",
                    "A4",
                    "B4",
                    "C5",
                    "D5",
                    "E5",
                ].map((note) => (
                    <div
                        class="white-key piano-key"
                        data-note={note}
                        data-freq={NOTE_FREQUENCIES[note] || 0}
                    />
                ))
            }

            <!-- Black keys with dynamic positioning across full range -->
            {
                [
                    { note: "A#3", index: 0 },

                    { note: "C#4", index: 2 },
                    { note: "D#4", index: 3 },
                    { note: "F#4", index: 5 },
                    { note: "G#4", index: 6 },
                    { note: "A#4", index: 7 },

                    { note: "C#5", index: 9 },
                    { note: "D#5", index: 10 },
                ].map(({ note, index }) => (
                    <div
                        class="black-key piano-key"
                        data-note={note}
                        data-freq={NOTE_FREQUENCIES[note] || 0}
                        style={`left: calc(${index} * 50px + 35px);`}
                    />
                ))
            }
        </div>
    </div>

    <!-- Keyboard Guide -->
    <div class="keyboard-guide">
        <p>Play with your keyboard!</p>
        <div class="key-map">
            <div class="key-row">
                <span class="key-black">2</span>
                <span class="key-spacer"></span>
                <span class="key-black">4</span>
                <span class="key-black">5</span>
                <span class="key-spacer"></span>
                <span class="key-black">7</span>
                <span class="key-black">8</span>
                <span class="key-black">9</span>
                <span class="key-spacer"></span>
                <span class="key-black">-</span>
                <span class="key-black">=</span>
            </div>
            <div class="key-row">
                <span class="key-white">Q</span>
                <span class="key-white">W</span>
                <span class="key-white">E</span>
                <span class="key-white">R</span>
                <span class="key-white">T</span>
                <span class="key-white">Y</span>
                <span class="key-white">U</span>
                <span class="key-white">I</span>
                <span class="key-white">O</span>
                <span class="key-white">P</span>
                <span class="key-white">[</span>
                <span class="key-white">]</span>
                <span class="key-white">\</span>
            </div>
        </div>
    </div>

    <!-- Control Panels -->
    <div class="control-section">
        <!-- Demo Songs -->
        <div class="piano-controls">
            <button class="demo-button" data-song="fur-elise"
                >Play FÃ¼r Elise</button
            >
            <button class="demo-button" data-song="moonlight-sonata"
                >Play Moonlight Sonata</button
            >
        </div>

        <!-- Recording Controls -->
        <div class="recording-controls">
            <button id="record-button">Record</button>
            <button id="play-recording" disabled>Play Recording</button>
        </div>

        <!-- Sound Effects - Replaced reverb with sustain -->
        <div class="sound-controls">
            <button id="sustain-button" class="pixel-button"
                >Sustain: OFF</button
            >

            <label for="instrument-select" class="ml-3">Instrument:</label>
            <select id="instrument-select">
                <option value="sine">Piano</option>
                <option value="square">Organ</option>
                <option value="sawtooth">Synth</option>
                <option value="triangle">Music Box</option>
            </select>
        </div>

        <!-- Learning Section -->
        <div class="learning-controls">
            <button class="chord-button" data-chord="C">C Major</button>
            <button class="chord-button" data-chord="G">G Major</button>
            <button class="chord-button" data-chord="Am">A Minor</button>
        </div>
    </div>
</div>

<script>
    // Type definitions
    type OscillatorType = "sine" | "square" | "sawtooth" | "triangle";

    interface AudioSystem {
        audioContext: AudioContext;
    }

    interface RecordingSystem {
        isRecording: boolean;
        recordedNotes: Array<{
            note: string | null;
            freq: number;
            time: number;
        }>;
        startTime: number;
    }

    interface SongNote {
        note: string;
        duration: number;
    }

    interface SongList {
        [key: string]: SongNote[];
    }

    // Get NOTE_FREQUENCIES from the data attribute - no need to redefine it
    const pianoDataElement = document.getElementById("piano-data");
    const NOTE_FREQUENCIES: Record<string, number> = pianoDataElement
        ? JSON.parse(pianoDataElement.getAttribute("data-frequencies") || "{}")
        : {};

    document.addEventListener("DOMContentLoaded", () => {
        // Audio system initialization - simplified, no reverb
        const audioSystem = initializeAudioSystem();
        if (!audioSystem) return;

        const { audioContext } = audioSystem;
        let currentWaveform: OscillatorType = "sine";
        let sustainActive = false; // New sustain state

        // Recording system state
        const recordingSystem: RecordingSystem = {
            isRecording: false,
            recordedNotes: [],
            startTime: 0,
        };

        // Initialize UI controls
        initializeControls(audioContext, recordingSystem);

        // Initialize piano key handlers
        initializePianoKeys(audioContext, recordingSystem);

        // Add keyboard controls
        initializeKeyboardControls();

        // Main function to play a note
        function playNote(noteName: string | null, frequency: number): void {
            if (!noteName || !audioContext) return;

            // Visual feedback
            const key = document.querySelector(`[data-note="${noteName}"]`);
            if (!key) return;

            // Highlight key
            key.classList.add("active");

            // Audio processing
            playSound(audioContext, frequency);

            // Record if recording is active
            if (recordingSystem.isRecording) {
                recordingSystem.recordedNotes.push({
                    note: noteName,
                    freq: frequency,
                    time: (Date.now() - recordingSystem.startTime) / 1000,
                });
            }
        }

        // NEW function to release a note
        function releaseNote(noteName: string | null): void {
            if (!noteName) return;

            const key = document.querySelector(`[data-note="${noteName}"]`);
            if (key) {
                key.classList.remove("active");
            }
        }

        // Initialize piano key handlers - UPDATED for proper press/release
        function initializePianoKeys(
            audioContext: AudioContext,
            recordingSystem: RecordingSystem,
        ): void {
            const allKeys = document.querySelectorAll(".white-key, .black-key");
            const activeKeys = new Set();

            allKeys.forEach((key) => {
                // Handle mouse down
                key.addEventListener("mousedown", (e) => {
                    const target = e.currentTarget as HTMLElement;
                    const noteName = target.getAttribute("data-note");
                    const frequency = parseFloat(
                        target.getAttribute("data-freq") || "0",
                    );
                    playNote(noteName, frequency);
                    if (noteName) activeKeys.add(noteName);
                });

                // Handle mouse up
                key.addEventListener("mouseup", (e) => {
                    const target = e.currentTarget as HTMLElement;
                    const noteName = target.getAttribute("data-note") as string | null;
                    if (noteName) {
                        releaseNote(noteName);
                        activeKeys.delete(noteName);
                    }
                });

                // Handle mouse leave - release if mouse leaves while pressed
                key.addEventListener("mouseleave", (e) => {
                    const target = e.currentTarget as HTMLElement;
                    const noteName = target.getAttribute("data-note") as string | null;
                    if (noteName && activeKeys.has(noteName)) {
                        releaseNote(noteName);
                        activeKeys.delete(noteName);
                    }
                });
            });

            // Handle cases where mouse is released outside the keys
            document.addEventListener("mouseup", () => {
                activeKeys.forEach((noteName) => {
                    releaseNote(noteName);
                });
                activeKeys.clear();
            });
        }

        // Add keyboard controls - UPDATED for proper press/release
        function initializeKeyboardControls(): void {
            // Keyboard mapping remains the same
            const keyboardMap: Record<string, string> = {
                // White keys - QWERTY keyboard layout
                q: "A3",
                w: "B3",
                e: "C4",
                r: "D4",
                t: "E4",
                y: "F4",
                u: "G4",
                i: "A4",
                o: "B4",
                p: "C5",
                "[": "D5",
                "]": "E5",
                "\\": "F5",

                // Black keys with correct positioning following piano pattern
                "2": "A#3",
                "4": "C#4",
                "5": "D#4",
                "7": "F#4",
                "8": "G#4",
                "9": "A#4",
                "-": "C#5",
                "=": "D#5",
            };

            const keysPressed: Record<string, boolean> = {};

            // Listen for key down events
            document.addEventListener("keydown", (event) => {
                const key = event.key.toLowerCase();

                // Only trigger if the key is in our map and not already pressed
                if (keyboardMap[key] && !keysPressed[key]) {
                    keysPressed[key] = true;

                    // Find matching piano key and get its frequency
                    const note = keyboardMap[key];
                    const frequency = NOTE_FREQUENCIES[note] || 0;

                    // Play the note
                    playNote(note, frequency);
                }
            });

            // Listen for key up events - UPDATED to release notes
            document.addEventListener("keyup", (event) => {
                const key = event.key.toLowerCase();

                // Release the note when key is released
                if (keyboardMap[key]) {
                    const note = keyboardMap[key];
                    releaseNote(note);
                    keysPressed[key] = false;
                }
            });
        }

        // Update playSong to handle note release properly
        function playSong(songName: string): void {
            if (!songName || !audioContext) return;

            const songs: SongList = {
                "fur-elise": [
                    { note: "E5", duration: 0.2 },
                    { note: "D#5", duration: 0.2 },
                    { note: "E5", duration: 0.2 },
                    { note: "D#5", duration: 0.2 },
                    { note: "E5", duration: 0.2 },
                    { note: "B4", duration: 0.2 },
                    { note: "D5", duration: 0.2 },
                    { note: "C5", duration: 0.2 },
                    { note: "A4", duration: 0.4 },
                ],
                "moonlight-sonata": [
                    { note: "C#3", duration: 0.5 },
                    { note: "G#3", duration: 0.5 },
                    { note: "C#4", duration: 0.5 },
                    { note: "G#3", duration: 0.5 },
                    { note: "C#4", duration: 0.5 },
                    { note: "G#3", duration: 0.5 },
                ],
            };

            if (songs[songName]) {
                let time = 0;
                songs[songName].forEach((note) => {
                    // Play note at the scheduled time
                    setTimeout(() => {
                        const freq = NOTE_FREQUENCIES[note.note] || 0;
                        playNote(note.note, freq);
                    }, time * 1000);

                    // Release note after its duration
                    setTimeout(
                        () => {
                            releaseNote(note.note);
                        },
                        (time + note.duration) * 1000,
                    );

                    time += note.duration;
                });
            }
        }

        // Initialize audio system - simplified, no reverb
        function initializeAudioSystem(): AudioSystem | null {
            try {
                const audioContext = new (window.AudioContext ||
                    ((window as any)
                        .webkitAudioContext as typeof AudioContext))();
                return { audioContext };
            } catch (e) {
                console.error("Web Audio API is not supported in this browser");
                return null;
            }
        }

        // Initialize UI controls - modified for sustain
        function initializeControls(
            audioContext: AudioContext,
            recordingSystem: RecordingSystem,
        ): void {
            // Sustain button
            const sustainButton = document.getElementById("sustain-button");
            if (sustainButton) {
                sustainButton.addEventListener("click", () => {
                    sustainActive = !sustainActive;
                    sustainButton.textContent = sustainActive
                        ? "Sustain: ON"
                        : "Sustain: OFF";
                    sustainButton.classList.toggle("active", sustainActive);
                });
            }

            // Instrument selection
            const instrumentSelect =
                document.getElementById("instrument-select");
            if (instrumentSelect) {
                instrumentSelect.addEventListener("change", (e) => {
                    const target = e.target as HTMLSelectElement;
                    currentWaveform = target.value as OscillatorType;
                });
            }

            // Demo song buttons
            document.querySelectorAll(".demo-button").forEach((button) => {
                button.addEventListener("click", () => {
                    const songName = button.getAttribute("data-song");
                    if (songName) {
                        playSong(songName);
                    }
                });
            });

            // Recording controls
            initializeRecordingControls(recordingSystem);

            // Chord buttons
            initializeChordButtons();
        }

        // Initialize recording controls
        function initializeRecordingControls(
            recordingSystem: RecordingSystem,
        ): void {
            const recordButton = document.getElementById("record-button");
            const playRecordingButton = document.getElementById(
                "play-recording",
            ) as HTMLButtonElement;

            // Track active playback timeouts to allow cancellation
            let playbackTimeouts: ReturnType<typeof setTimeout>[] = [];
            let isPlaying = false;

            if (recordButton) {
                recordButton.addEventListener("click", () => {
                    if (!recordingSystem.isRecording) {
                        // Start recording
                        recordingSystem.recordedNotes = [];
                        recordingSystem.startTime = Date.now();
                        recordingSystem.isRecording = true;
                        recordButton.textContent = "Stop Recording";
                        recordButton.classList.add("recording");

                        // Disable playback while recording
                        if (playRecordingButton) {
                            playRecordingButton.disabled = true;
                        }
                    } else {
                        // Stop recording
                        recordingSystem.isRecording = false;
                        recordButton.textContent = "Record";
                        recordButton.classList.remove("recording");

                        // Only enable playback if we have recorded notes
                        if (
                            playRecordingButton &&
                            recordingSystem.recordedNotes.length > 0
                        ) {
                            playRecordingButton.disabled = false;
                            playRecordingButton.textContent = "Play Recording";
                        }
                    }
                });
            }

            if (playRecordingButton) {
                playRecordingButton.addEventListener("click", () => {
                    // If already playing, stop playback
                    if (isPlaying) {
                        // Clear all scheduled timeouts
                        playbackTimeouts.forEach((timeoutId) =>
                            clearTimeout(timeoutId),
                        );
                        playbackTimeouts = [];

                        // Release any active keys
                        document
                            .querySelectorAll(".piano-key.active")
                            .forEach((key) => {
                                const noteName = (
                                    key as HTMLElement
                                ).getAttribute("data-note");
                                if (noteName) releaseNote(noteName);
                            });

                        isPlaying = false;
                        playRecordingButton.textContent = "Play Recording";
                        return;
                    }

                    // Start playback
                    isPlaying = true;
                    playRecordingButton.textContent = "Stop Playback";

                    // Clear previous timeouts
                    playbackTimeouts = [];

                    // Find the last note time to know when playback is complete
                    const lastNoteTime = recordingSystem.recordedNotes.reduce(
                        (max, note) => Math.max(max, note.time),
                        0,
                    );

                    // Play each recorded note with proper release
                    recordingSystem.recordedNotes.forEach((note) => {
                        // Schedule note playback
                        const playTimeout = setTimeout(() => {
                            playNote(note.note, note.freq);
                        }, note.time * 1000);
                        playbackTimeouts.push(playTimeout);

                        // Schedule note release (assuming 0.3s duration for each note)
                        const releaseTimeout = setTimeout(
                            () => {
                                releaseNote(note.note);
                            },
                            (note.time + 0.3) * 1000,
                        );
                        playbackTimeouts.push(releaseTimeout);
                    });

                    // Reset play button state when playback completes
                    const resetTimeout = setTimeout(
                        () => {
                            isPlaying = false;
                            playRecordingButton.textContent = "Play Recording";
                        },
                        (lastNoteTime + 0.5) * 1000,
                    );
                    playbackTimeouts.push(resetTimeout);
                });
            }
        }

        // Initialize chord buttons
        function initializeChordButtons(): void {
            const chords: Record<string, string[]> = {
                C: ["C4", "E4", "G4"],
                G: ["G4", "B4", "D5"],
                Am: ["A4", "C5", "E5"],
            };

            document.querySelectorAll(".chord-button").forEach((button) => {
                button.addEventListener("click", () => {
                    // Clear any existing highlighted keys
                    document.querySelectorAll(".piano-key").forEach((key) => {
                        key.classList.remove("highlight");
                    });

                    // Get chord name and highlight keys
                    const chordName = button.getAttribute("data-chord");
                    if (chordName && chords[chordName]) {
                        chords[chordName].forEach((note) => {
                            const key = document.querySelector(
                                `.piano-key[data-note="${note}"]`,
                            );
                            if (key) {
                                key.classList.add("highlight");
                            }
                        });
                    }
                });
            });
        }

        // Sound generation function with sustain parameter
        function playSound(
            audioContext: AudioContext,
            frequency: number,
        ): void {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();

            // Set oscillator properties
            oscillator.type = currentWaveform;
            oscillator.frequency.value = frequency;

            // Configure gain node for volume and release
            gainNode.gain.setValueAtTime(0.7, audioContext.currentTime);

            // Set release time based on sustain state
            const releaseTime = sustainActive ? 2.0 : 0.5;

            // Apply decay curve
            gainNode.gain.exponentialRampToValueAtTime(
                0.001,
                audioContext.currentTime + releaseTime,
            );

            // Connect nodes
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // Start and stop oscillator
            oscillator.start();
            oscillator.stop(audioContext.currentTime + releaseTime);
        }
    });
</script>

<style>
    /* Fix for the missing dot in the selector */
    .piano-container {
        margin: 2rem 0;
        text-align: center;
        font-family: "Press Start 2P", "Courier New", monospace; /* Pixel font */
    }

    .piano {
        margin: 1.5rem auto;
        width: 100%;
        max-width: 600px;
        image-rendering: pixelated;
        image-rendering: crisp-edges;
        box-shadow: 0px 6px 0px #333;
        border: 2px solid #111;
        padding: 10px;
        background: #555;
        border-radius: 4px;
    }

    .keyboard {
        position: relative;
        display: flex;
        justify-content: center;
        height: 200px;
        width: 600px;
        margin: 0 auto;
        overflow-x: auto;
    }

    /* Pixelated white keys */
    .white-key {
        width: 50px;
        height: 200px;
        background-color: #ffffff;
        border: 2px solid #333;
        border-radius: 2px;
        box-sizing: border-box;
        display: flex;
        align-items: flex-end;
        justify-content: center;
        padding-bottom: 10px;
        cursor: pointer;
        z-index: 1;
        image-rendering: pixelated;
    }

    /* Replace the black key styles with solid backgrounds */
    .black-key {
        position: absolute;
        width: 30px;
        height: 120px;
        background-color: #111111;
        border: 2px solid #000;
        border-radius: 0;
        top: 0;
        z-index: 2;
        cursor: pointer;
        image-rendering: pixelated;
        box-shadow: inset 0px 0px 0px 2px rgba(255, 255, 255, 0.1);
    }

    /* Update hover states */
    .white-key:hover {
        background-color: #f0f0f0;
        border-color: #666;
    }

    .black-key:hover {
        background-color: #333333;
        box-shadow: inset 0px 0px 0px 2px rgba(255, 255, 255, 0.3);
        border-color: #444;
    }

    /* Updated white-key.active style - no transform */
    .white-key.active {
        background-color: #e0e0e0;
        border-color: #222;
        box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.2); /* Add inset shadow instead of movement */
    }

    .black-key.active {
        background-color: #000000;
        box-shadow: none;
    }

    /* Update highlight states */
    .white-key.highlight {
        background-color: #ffffaa;
        border: 2px solid #ffd700 !important;
        box-shadow:
            0 0 8px #ffd700,
            inset 0 0 6px #ffd700 !important;
    }

    .black-key.highlight {
        background-color: #333311;
        border: 2px solid #ffd700 !important;
        box-shadow:
            0 0 8px #ffd700,
            inset 0 0 4px #ffd700 !important;
    }

    .key-spacer {
        display: inline-block;
        width: 16px;
        height: 1px;
    }

    .key-label {
        font-family: "Press Start 2P", "Courier New", monospace;
        font-size: 10px;
        color: #000;
        margin-bottom: 5px;
        pointer-events: none;
        text-shadow: 1px 1px 0px #fff;
    }

    /* Retro style controls */
    .control-section {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        gap: 0.5rem;
        margin: 1.5rem auto;
        max-width: 600px;
        background: #333;
        padding: 10px;
        border: 2px solid #111;
        border-radius: 4px;
    }

    button {
        margin: 0.3rem;
        padding: 0.5rem;
        font-size: 0.8rem;
        font-family: "Press Start 2P", "Courier New", monospace;
        cursor: pointer;
        border: none;
        border-radius: 0;
        transition: all 0.1s ease;
        box-shadow:
            inset -2px -2px 0 #111,
            inset 2px 2px 0 #aaa;
        image-rendering: pixelated;
    }

    button:active {
        box-shadow:
            inset 2px 2px 0 #111,
            inset -2px -2px 0 #aaa;
        transform: translateY(2px);
    }

    /* Pixel art sustain button styles */
    #sustain-button {
        background-color: #8866dd;
        color: white;
        border: 2px solid #111;
        padding: 8px 16px;
        position: relative;
    }

    #sustain-button:before {
        content: "";
        position: absolute;
        top: 2px;
        left: 2px;
        right: 2px;
        height: 4px;
        background: rgba(255, 255, 255, 0.4);
    }

    #sustain-button.active {
        background-color: #bb44ff;
        box-shadow:
            inset 2px 2px 0 #111,
            inset -2px -2px 0 #aaa,
            0 0 8px #bb44ff;
    }

    .demo-button {
        background-color: #4477ff;
        color: white;
    }

    #record-button {
        background-color: #555;
        color: white;
    }

    .recording {
        background-color: #ff3333 !important;
        animation: pixelPulse 0.8s infinite steps(2);
    }

    @keyframes pixelPulse {
        0% {
            background-color: #ff3333;
        }
        50% {
            background-color: #aa0000;
        }
        100% {
            background-color: #ff3333;
        }
    }

    .sound-controls {
        display: flex;
        align-items: center;
        gap: 10px;
        margin: 0 10px;
    }

    .sound-controls select {
        background: #222;
        color: #eee;
        border: 2px solid #111;
        font-family: "Press Start 2P", "Courier New", monospace;
        font-size: 10px;
        padding: 5px;
    }

    .keyboard-guide {
        margin: 1rem auto;
        max-width: 600px;
        background: #222;
        padding: 8px;
        border: 2px solid #111;
        border-radius: 4px;
        color: #ddd;
        font-size: 0.8rem;
    }

    .key-map {
        display: flex;
        flex-direction: column;
        gap: 5px;
        margin-top: 8px;
    }

    .key-row {
        display: flex;
        justify-content: center;
        gap: 4px;
        align-items: center;
    }

    .key-white,
    .key-black {
        display: inline-block;
        padding: 4px 8px;
        border-radius: 2px;
        font-family: "Courier New", monospace;
    }

    .key-white {
        background: #f0f0f0;
        color: #222;
    }

    .key-black {
        background: #444;
        color: #fff;
    }
</style>
